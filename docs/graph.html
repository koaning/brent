<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.2" />
<title>brent.graph API documentation</title>
<meta name="description" content="The `brent.graph` module contains the DAG object. This is the
main object that you&#39;ll talk to when constructing a casual graph." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}#index .two-column{column-count:2}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="icon" href="https://pdoc.github.io/pdoc/logo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>brent.graph</code> module</h1>
</header>
<section id="section-intro">
<p>The <a title="brent.graph" href="#brent.graph"><code>brent.graph</code></a> module contains the DAG object. This is the
main object that you'll talk to when constructing a casual graph.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;
The `brent.graph` module contains the DAG object. This is the
main object that you&#39;ll talk to when constructing a casual graph.
&#34;&#34;&#34;

import logging

import numpy as np
import pandas as pd
import networkx as nx
from graphviz import Digraph

from brent.common import normalise, window, is_path_blocked


class DAG:
    &#34;&#34;&#34;
    A `brent.DAG` object describes a graphical model of a dataset. This
    object is generated from a pandas dataframe. Every column in the
    dataframe will result in a node/variable in the `brent.DAG` object.

    ```
    from brent import DAG
    from brent.common import make_fake_df
    # let&#39;s start with a new dataset
    df = make_fake_df(4)
    dag = DAG(df).add_edge(&#34;a&#34;, &#34;b&#34;).add_edge(&#34;b&#34;, &#34;c&#34;).add_edge(&#34;c&#34;,&#34;d&#34;)
    ```
    &#34;&#34;&#34;
    def __init__(self, dataframe: pd.DataFrame):
        &#34;&#34;&#34;
        Create a new `brent.DAG` from a dataframe.

        Inputs:

        - **dataframe**: pandas object that contains all variables

        Example:

        ```
        from brent import DAG
        from brent.common import make_fake_df
        # let&#39;s start with a new dataset
        df = make_fake_df(4)
        dag = DAG(df).add_edge(&#34;a&#34;, &#34;b&#34;).add_edge(&#34;b&#34;, &#34;c&#34;).add_edge(&#34;c&#34;,&#34;d&#34;)
        ```
        &#34;&#34;&#34;
        self.df = dataframe
        self.graph = nx.DiGraph()
        for node in self.df.columns:
            self.graph.add_node(node)

    @property
    def undirected(self):
        &#34;&#34;&#34;
        Fetch the `undirected` variant of the NetworkX graph. This can be
        useful when trying to determine all paths between two nodes.
        &#34;&#34;&#34;
        return self.graph.to_undirected()

    @property
    def origin_nodes(self):
        &#34;&#34;&#34;These nodes are nodes that do not have any edges going in.&#34;&#34;&#34;
        return tuple(x for x in self.graph.nodes() if self.graph.in_degree(x) == 0)

    @property
    def marginal_table(self):
        &#34;&#34;&#34;
        The marginal table is a table with all possible values and associated probability.
        &#34;&#34;&#34;
        nodes = list(self.graph.nodes)
        logging.debug(f&#34;about to calculate marginal table with nodes {nodes}&#34;)
        logging.debug(f&#34;updating table for node {nodes[-1]}&#34;)
        marginal = self.calc_node_table(nodes.pop())
        logging.debug(f&#34;current node table:\n{marginal}&#34;)
        logging.debug(f&#34;current marginal table:\n{marginal}&#34;)
        for node in nodes:
            logging.debug(f&#34;updating table for node {node}&#34;)
            logging.debug(f&#34;current node table:\n{self.calc_node_table(node)}&#34;)
            marginal = self.merge_probs(marginal, self.calc_node_table(node))
            logging.debug(f&#34;current marginal table:\n{marginal}&#34;)
        return marginal

    @property
    def nodes(self):
        &#34;&#34;&#34;The nodes of the graph.&#34;&#34;&#34;
        return list(self.graph.nodes)

    @property
    def edges(self):
        &#34;&#34;&#34;The edges of the graph.&#34;&#34;&#34;
        return list(self.graph.edges)

    def copy(self):
        &#34;&#34;&#34;Returns a copy of the current DAG.&#34;&#34;&#34;
        new_dag = DAG(self.df)
        new_dag.graph = self.graph
        return new_dag

    def edge_direction(self, node_a, node_b):
        &#34;&#34;&#34;Determines the `&lt;-` vs. `-&gt;` direction of an edge between two nodes.&#34;&#34;&#34;
        if node_b in self.parents(node_a):
            return &#34;&lt;-&#34;
        if node_a in self.parents(node_b):
            return &#34;-&gt;&#34;
        raise ValueError(f&#34;node &#39;{node_a}&#39; is not connected to &#39;{node_b}&#39;&#34;)

    def undirected_paths(self, node_a, node_b):
        &#34;&#34;&#34;
        Returns a list of all the paths that are between `node_a` and `node_b`.
        These paths do not take the direction into account and will turn the
        directed graph into an undirected one.
        &#34;&#34;&#34;
        return list(nx.all_simple_paths(self.undirected, node_a, node_b))

    def directed_paths(self, node_a, node_b):
        output_paths = []
        for path in self.undirected_paths(node_a, node_b):
            windowed = list(window(path))
            new_path = []
            for n1, n2 in windowed:
                new_path.append(n1)
                new_path.append(self.edge_direction(n1, n2))
            new_path.append(n2)
            output_paths.append(new_path)
            logging.debug(f&#34;found directed path: {&#39; &#39;.join(new_path)}&#34;)
        return output_paths

    def active_paths(self, node_a, node_b, z=list()):
        &#34;&#34;&#34;
        Returns a list of all the paths that can influence probability between
        `node_a` and `node_b`. You can also supply a collection of nodes `z` that
        are given. These nodes might block (or enable) a path to be active. If there
        are no active paths between two nodes then this means that the two nodes
        are (conditionally if `z` is given) independant.
        &#34;&#34;&#34;
        undirected_paths = self.directed_paths(node_a, node_b)
        active_paths = []
        for path in undirected_paths:
            z_path = [f&#34;given({_})&#34; if _ in z else _ for _ in path]
            logging.debug(f&#34;now checking {&#39; &#39;.join(z_path)}&#34;)
            if not is_path_blocked(z_path):
                active_paths.append(z_path)
        return active_paths

    def calc_node_table(self, name):
        &#34;&#34;&#34;
        Calculates probability table for a given node.

        Suppose we have graph `A -&gt; B -&gt; C`: `.calc_node_table(&#34;b&#34;)`
        call will calculate `P(B|A)` in the `probs` column of the result.

        ## Input

        - **name**: Name of a node/variable in the graph
        &#34;&#34;&#34;
        parents = self.parents(name)
        tbl = self.df.copy()
        logging.debug(f&#34;creating node table node={name} parents={parents}&#34;)

        def calculate_parents_size(dataf, groups=[]):
            return (dataf
                    .assign(count=1)
                    .groupby(groups)
                    .transform(np.sum)[&#39;count&#39;])

        if len(parents) == 0:
            tbl = tbl.assign(parent_size=lambda d: d.shape[0])
        else:
            tbl = tbl.assign(parent_size=lambda d: calculate_parents_size(d, list(parents)))
        return (tbl
                .assign(node_size=lambda d: calculate_parents_size(d, list(parents) + [name]))
                .assign(prob=lambda d: d[&#39;node_size&#39;] / d[&#39;parent_size&#39;])
                [list(parents) + [name] + [&#34;prob&#34;]]
                .drop_duplicates()
                .reset_index(drop=True))

    def merge_probs(self, this_df, that_df):
        &#34;&#34;&#34;
        Merges two probability dataframes while checking if nodes
        are connected in the graph. If `this_df` denotes `p(C|A,B)`
        in table form and `that_df` denotes `p(B|A)` in table form
        then the output of this function will denote `p(C,B|A)` in
        table form. Note that this method is mainly meant for internal usage.

        ## Input

        - **this_df**: Name of a node/variable in the graph, say `p(C|A,B)`
        - **that_df**: Name of a node/variable in the graph, say `p(B|A)`

        ## Output

        A dataframe that merges the two former tables, say `p(C,B|A)`.
        &#34;&#34;&#34;
        common_cols = list(set(this_df.columns)
                           .intersection(set(that_df.columns))
                           .difference({&#34;prob&#34;}))
        if len(common_cols) == 0:
            columns = set(that_df.columns).difference({&#34;prob&#34;})
            loose_tables = []
            for c in columns:
                for value in self.calc_node_table(c)[c].values:
                    loose_tables.append(this_df.assign(**{c: value}))
            join_able = pd.concat(loose_tables)
            return self.merge_probs(join_able, that_df)
        return (this_df
                .set_index(common_cols)
                .join(that_df.set_index(common_cols), lsuffix=&#34;1&#34;, rsuffix=&#34;2&#34;)
                .assign(prob=lambda x: normalise(x.prob1 * x.prob2))
                .drop(&#34;prob1&#34;, axis=1)
                .drop(&#34;prob2&#34;, axis=1)
                .reset_index())

    def add_edge(self, source, sink) -&gt; &#39;DAG&#39;:
        &#34;&#34;&#34;
        Adds an edge to the graph.

        ## Input

        - **source**: Name of a node in the graph
        - **sink**: Name of a node in the graph

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))
        ```
        &#34;&#34;&#34;
        if source not in self.df.columns:
            raise ValueError(f&#34;cause {source} not in dataframe&#34;)
        if sink not in self.df.columns:
            raise ValueError(f&#34;effect {sink} not in dataframe&#34;)
        new_graph = self.graph.copy()
        new_graph.add_edge(source, sink)
        if not nx.is_directed_acyclic_graph(new_graph):
            raise ValueError(f&#34;edge {source} -&gt; {sink} causes DAG to get cycle&#34;)
        self.graph.add_edge(source, sink)
        logging.debug(f&#34;created connection {source} -&gt; {sink}&#34;)
        return self

    def children(self, node):
        &#34;&#34;&#34;
        Return the children of a node.

        ## Input

        - **node**: Name of a node

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        dag = (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))

        dag.children(&#34;b&#34;) #outputs &#34;c&#34;
        dag.children(&#34;c&#34;) #outputs &#34;d&#34;
        ```
        &#34;&#34;&#34;
        return set(self.graph.successors(node))

    def parents(self, node):
        &#34;&#34;&#34;
        Return the parents of a node.

        ## Input

        - **node**: Name of a node

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        dag = (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))

        dag.children(&#34;b&#34;) #outputs &#34;a&#34;
        dag.children(&#34;c&#34;) #outputs &#34;b&#34;
        ```
        &#34;&#34;&#34;
        return set(self.graph.predecessors(node))

    def connections(self, node):
        &#34;&#34;&#34;
        Return all nodes connected to the one passed in.

        ## Input

        - **node**: Name of a node

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        dag = (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))

        dag.children(&#34;b&#34;) #outputs [&#34;a&#34;,&#34;c&#34;]
        dag.children(&#34;c&#34;) #outputs [&#34;b&#34;,&#34;d&#34;]
        ```
        &#34;&#34;&#34;
        return set(list(self.children(node)) + list(self.parents(node)))

    def independences(self):
        &#34;&#34;&#34;
        **NOT IMPLEMENTED YET**
        &#34;&#34;&#34;
        # https://www.slideshare.net/duytungpham18/lecture-1-graphical-models
        pass

    def plot(self):
        &#34;&#34;&#34;A pretty plotting function.&#34;&#34;&#34;
        d = Digraph()
        d.attr(rankdir=&#39;LR&#39;)
        d.attr(&#39;node&#39;, shape=&#39;circle&#39;)
        for n in self.graph.nodes:
            d.node(n)
        for n1, n2 in self.graph.edges:
            d.edge(n1, n2)
        return d

    def nx_plot(self, **kwargs):
        &#34;&#34;&#34;
        A customizable plotting function. The function comes from `networkx`.
        It merely wraps around the `nx.draw` method, documentation of this project
        can be found [here](https://networkx.github.io/documentation/stable/index.html).
        &#34;&#34;&#34;
        nx.draw(self.graph, node_size=500, with_labels=True, node_color=&#34;white&#34;, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="brent.graph.DAG"><code class="flex name class">
<span>class <span class="ident">DAG</span></span>
</code></dt>
<dd>
<section class="desc"><p>A <code>brent.DAG</code> object describes a graphical model of a dataset. This
object is generated from a pandas dataframe. Every column in the
dataframe will result in a node/variable in the <code>brent.DAG</code> object.</p>
<pre><code>from brent import DAG
from brent.common import make_fake_df
# let's start with a new dataset
df = make_fake_df(4)
dag = DAG(df).add_edge(&quot;a&quot;, &quot;b&quot;).add_edge(&quot;b&quot;, &quot;c&quot;).add_edge(&quot;c&quot;,&quot;d&quot;)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class DAG:
    &#34;&#34;&#34;
    A `brent.DAG` object describes a graphical model of a dataset. This
    object is generated from a pandas dataframe. Every column in the
    dataframe will result in a node/variable in the `brent.DAG` object.

    ```
    from brent import DAG
    from brent.common import make_fake_df
    # let&#39;s start with a new dataset
    df = make_fake_df(4)
    dag = DAG(df).add_edge(&#34;a&#34;, &#34;b&#34;).add_edge(&#34;b&#34;, &#34;c&#34;).add_edge(&#34;c&#34;,&#34;d&#34;)
    ```
    &#34;&#34;&#34;
    def __init__(self, dataframe: pd.DataFrame):
        &#34;&#34;&#34;
        Create a new `brent.DAG` from a dataframe.

        Inputs:

        - **dataframe**: pandas object that contains all variables

        Example:

        ```
        from brent import DAG
        from brent.common import make_fake_df
        # let&#39;s start with a new dataset
        df = make_fake_df(4)
        dag = DAG(df).add_edge(&#34;a&#34;, &#34;b&#34;).add_edge(&#34;b&#34;, &#34;c&#34;).add_edge(&#34;c&#34;,&#34;d&#34;)
        ```
        &#34;&#34;&#34;
        self.df = dataframe
        self.graph = nx.DiGraph()
        for node in self.df.columns:
            self.graph.add_node(node)

    @property
    def undirected(self):
        &#34;&#34;&#34;
        Fetch the `undirected` variant of the NetworkX graph. This can be
        useful when trying to determine all paths between two nodes.
        &#34;&#34;&#34;
        return self.graph.to_undirected()

    @property
    def origin_nodes(self):
        &#34;&#34;&#34;These nodes are nodes that do not have any edges going in.&#34;&#34;&#34;
        return tuple(x for x in self.graph.nodes() if self.graph.in_degree(x) == 0)

    @property
    def marginal_table(self):
        &#34;&#34;&#34;
        The marginal table is a table with all possible values and associated probability.
        &#34;&#34;&#34;
        nodes = list(self.graph.nodes)
        logging.debug(f&#34;about to calculate marginal table with nodes {nodes}&#34;)
        logging.debug(f&#34;updating table for node {nodes[-1]}&#34;)
        marginal = self.calc_node_table(nodes.pop())
        logging.debug(f&#34;current node table:\n{marginal}&#34;)
        logging.debug(f&#34;current marginal table:\n{marginal}&#34;)
        for node in nodes:
            logging.debug(f&#34;updating table for node {node}&#34;)
            logging.debug(f&#34;current node table:\n{self.calc_node_table(node)}&#34;)
            marginal = self.merge_probs(marginal, self.calc_node_table(node))
            logging.debug(f&#34;current marginal table:\n{marginal}&#34;)
        return marginal

    @property
    def nodes(self):
        &#34;&#34;&#34;The nodes of the graph.&#34;&#34;&#34;
        return list(self.graph.nodes)

    @property
    def edges(self):
        &#34;&#34;&#34;The edges of the graph.&#34;&#34;&#34;
        return list(self.graph.edges)

    def copy(self):
        &#34;&#34;&#34;Returns a copy of the current DAG.&#34;&#34;&#34;
        new_dag = DAG(self.df)
        new_dag.graph = self.graph
        return new_dag

    def edge_direction(self, node_a, node_b):
        &#34;&#34;&#34;Determines the `&lt;-` vs. `-&gt;` direction of an edge between two nodes.&#34;&#34;&#34;
        if node_b in self.parents(node_a):
            return &#34;&lt;-&#34;
        if node_a in self.parents(node_b):
            return &#34;-&gt;&#34;
        raise ValueError(f&#34;node &#39;{node_a}&#39; is not connected to &#39;{node_b}&#39;&#34;)

    def undirected_paths(self, node_a, node_b):
        &#34;&#34;&#34;
        Returns a list of all the paths that are between `node_a` and `node_b`.
        These paths do not take the direction into account and will turn the
        directed graph into an undirected one.
        &#34;&#34;&#34;
        return list(nx.all_simple_paths(self.undirected, node_a, node_b))

    def directed_paths(self, node_a, node_b):
        output_paths = []
        for path in self.undirected_paths(node_a, node_b):
            windowed = list(window(path))
            new_path = []
            for n1, n2 in windowed:
                new_path.append(n1)
                new_path.append(self.edge_direction(n1, n2))
            new_path.append(n2)
            output_paths.append(new_path)
            logging.debug(f&#34;found directed path: {&#39; &#39;.join(new_path)}&#34;)
        return output_paths

    def active_paths(self, node_a, node_b, z=list()):
        &#34;&#34;&#34;
        Returns a list of all the paths that can influence probability between
        `node_a` and `node_b`. You can also supply a collection of nodes `z` that
        are given. These nodes might block (or enable) a path to be active. If there
        are no active paths between two nodes then this means that the two nodes
        are (conditionally if `z` is given) independant.
        &#34;&#34;&#34;
        undirected_paths = self.directed_paths(node_a, node_b)
        active_paths = []
        for path in undirected_paths:
            z_path = [f&#34;given({_})&#34; if _ in z else _ for _ in path]
            logging.debug(f&#34;now checking {&#39; &#39;.join(z_path)}&#34;)
            if not is_path_blocked(z_path):
                active_paths.append(z_path)
        return active_paths

    def calc_node_table(self, name):
        &#34;&#34;&#34;
        Calculates probability table for a given node.

        Suppose we have graph `A -&gt; B -&gt; C`: `.calc_node_table(&#34;b&#34;)`
        call will calculate `P(B|A)` in the `probs` column of the result.

        ## Input

        - **name**: Name of a node/variable in the graph
        &#34;&#34;&#34;
        parents = self.parents(name)
        tbl = self.df.copy()
        logging.debug(f&#34;creating node table node={name} parents={parents}&#34;)

        def calculate_parents_size(dataf, groups=[]):
            return (dataf
                    .assign(count=1)
                    .groupby(groups)
                    .transform(np.sum)[&#39;count&#39;])

        if len(parents) == 0:
            tbl = tbl.assign(parent_size=lambda d: d.shape[0])
        else:
            tbl = tbl.assign(parent_size=lambda d: calculate_parents_size(d, list(parents)))
        return (tbl
                .assign(node_size=lambda d: calculate_parents_size(d, list(parents) + [name]))
                .assign(prob=lambda d: d[&#39;node_size&#39;] / d[&#39;parent_size&#39;])
                [list(parents) + [name] + [&#34;prob&#34;]]
                .drop_duplicates()
                .reset_index(drop=True))

    def merge_probs(self, this_df, that_df):
        &#34;&#34;&#34;
        Merges two probability dataframes while checking if nodes
        are connected in the graph. If `this_df` denotes `p(C|A,B)`
        in table form and `that_df` denotes `p(B|A)` in table form
        then the output of this function will denote `p(C,B|A)` in
        table form. Note that this method is mainly meant for internal usage.

        ## Input

        - **this_df**: Name of a node/variable in the graph, say `p(C|A,B)`
        - **that_df**: Name of a node/variable in the graph, say `p(B|A)`

        ## Output

        A dataframe that merges the two former tables, say `p(C,B|A)`.
        &#34;&#34;&#34;
        common_cols = list(set(this_df.columns)
                           .intersection(set(that_df.columns))
                           .difference({&#34;prob&#34;}))
        if len(common_cols) == 0:
            columns = set(that_df.columns).difference({&#34;prob&#34;})
            loose_tables = []
            for c in columns:
                for value in self.calc_node_table(c)[c].values:
                    loose_tables.append(this_df.assign(**{c: value}))
            join_able = pd.concat(loose_tables)
            return self.merge_probs(join_able, that_df)
        return (this_df
                .set_index(common_cols)
                .join(that_df.set_index(common_cols), lsuffix=&#34;1&#34;, rsuffix=&#34;2&#34;)
                .assign(prob=lambda x: normalise(x.prob1 * x.prob2))
                .drop(&#34;prob1&#34;, axis=1)
                .drop(&#34;prob2&#34;, axis=1)
                .reset_index())

    def add_edge(self, source, sink) -&gt; &#39;DAG&#39;:
        &#34;&#34;&#34;
        Adds an edge to the graph.

        ## Input

        - **source**: Name of a node in the graph
        - **sink**: Name of a node in the graph

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))
        ```
        &#34;&#34;&#34;
        if source not in self.df.columns:
            raise ValueError(f&#34;cause {source} not in dataframe&#34;)
        if sink not in self.df.columns:
            raise ValueError(f&#34;effect {sink} not in dataframe&#34;)
        new_graph = self.graph.copy()
        new_graph.add_edge(source, sink)
        if not nx.is_directed_acyclic_graph(new_graph):
            raise ValueError(f&#34;edge {source} -&gt; {sink} causes DAG to get cycle&#34;)
        self.graph.add_edge(source, sink)
        logging.debug(f&#34;created connection {source} -&gt; {sink}&#34;)
        return self

    def children(self, node):
        &#34;&#34;&#34;
        Return the children of a node.

        ## Input

        - **node**: Name of a node

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        dag = (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))

        dag.children(&#34;b&#34;) #outputs &#34;c&#34;
        dag.children(&#34;c&#34;) #outputs &#34;d&#34;
        ```
        &#34;&#34;&#34;
        return set(self.graph.successors(node))

    def parents(self, node):
        &#34;&#34;&#34;
        Return the parents of a node.

        ## Input

        - **node**: Name of a node

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        dag = (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))

        dag.children(&#34;b&#34;) #outputs &#34;a&#34;
        dag.children(&#34;c&#34;) #outputs &#34;b&#34;
        ```
        &#34;&#34;&#34;
        return set(self.graph.predecessors(node))

    def connections(self, node):
        &#34;&#34;&#34;
        Return all nodes connected to the one passed in.

        ## Input

        - **node**: Name of a node

        ## Example

        ```
        from brent import DAG
        from brent.common import make_fake_df

        dag = (DAG(dataframe=make_fake_df(4))
            .add_edge(&#34;a&#34;, &#34;b&#34;)
            .add_edge(&#34;b&#34;, &#34;c&#34;)
            .add_edge(&#34;c&#34;, &#34;d&#34;))

        dag.children(&#34;b&#34;) #outputs [&#34;a&#34;,&#34;c&#34;]
        dag.children(&#34;c&#34;) #outputs [&#34;b&#34;,&#34;d&#34;]
        ```
        &#34;&#34;&#34;
        return set(list(self.children(node)) + list(self.parents(node)))

    def independences(self):
        &#34;&#34;&#34;
        **NOT IMPLEMENTED YET**
        &#34;&#34;&#34;
        # https://www.slideshare.net/duytungpham18/lecture-1-graphical-models
        pass

    def plot(self):
        &#34;&#34;&#34;A pretty plotting function.&#34;&#34;&#34;
        d = Digraph()
        d.attr(rankdir=&#39;LR&#39;)
        d.attr(&#39;node&#39;, shape=&#39;circle&#39;)
        for n in self.graph.nodes:
            d.node(n)
        for n1, n2 in self.graph.edges:
            d.edge(n1, n2)
        return d

    def nx_plot(self, **kwargs):
        &#34;&#34;&#34;
        A customizable plotting function. The function comes from `networkx`.
        It merely wraps around the `nx.draw` method, documentation of this project
        can be found [here](https://networkx.github.io/documentation/stable/index.html).
        &#34;&#34;&#34;
        nx.draw(self.graph, node_size=500, with_labels=True, node_color=&#34;white&#34;, **kwargs)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="brent.graph.DAG.edges"><code class="name">var <span class="ident">edges</span></code></dt>
<dd>
<section class="desc"><p>The edges of the graph.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def edges(self):
    &#34;&#34;&#34;The edges of the graph.&#34;&#34;&#34;
    return list(self.graph.edges)</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.marginal_table"><code class="name">var <span class="ident">marginal_table</span></code></dt>
<dd>
<section class="desc"><p>The marginal table is a table with all possible values and associated probability.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def marginal_table(self):
    &#34;&#34;&#34;
    The marginal table is a table with all possible values and associated probability.
    &#34;&#34;&#34;
    nodes = list(self.graph.nodes)
    logging.debug(f&#34;about to calculate marginal table with nodes {nodes}&#34;)
    logging.debug(f&#34;updating table for node {nodes[-1]}&#34;)
    marginal = self.calc_node_table(nodes.pop())
    logging.debug(f&#34;current node table:\n{marginal}&#34;)
    logging.debug(f&#34;current marginal table:\n{marginal}&#34;)
    for node in nodes:
        logging.debug(f&#34;updating table for node {node}&#34;)
        logging.debug(f&#34;current node table:\n{self.calc_node_table(node)}&#34;)
        marginal = self.merge_probs(marginal, self.calc_node_table(node))
        logging.debug(f&#34;current marginal table:\n{marginal}&#34;)
    return marginal</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.nodes"><code class="name">var <span class="ident">nodes</span></code></dt>
<dd>
<section class="desc"><p>The nodes of the graph.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def nodes(self):
    &#34;&#34;&#34;The nodes of the graph.&#34;&#34;&#34;
    return list(self.graph.nodes)</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.origin_nodes"><code class="name">var <span class="ident">origin_nodes</span></code></dt>
<dd>
<section class="desc"><p>These nodes are nodes that do not have any edges going in.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def origin_nodes(self):
    &#34;&#34;&#34;These nodes are nodes that do not have any edges going in.&#34;&#34;&#34;
    return tuple(x for x in self.graph.nodes() if self.graph.in_degree(x) == 0)</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.undirected"><code class="name">var <span class="ident">undirected</span></code></dt>
<dd>
<section class="desc"><p>Fetch the <code>undirected</code> variant of the NetworkX graph. This can be
useful when trying to determine all paths between two nodes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def undirected(self):
    &#34;&#34;&#34;
    Fetch the `undirected` variant of the NetworkX graph. This can be
    useful when trying to determine all paths between two nodes.
    &#34;&#34;&#34;
    return self.graph.to_undirected()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="brent.graph.DAG.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, dataframe)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a new <code>brent.DAG</code> from a dataframe.</p>
<p>Inputs:</p>
<ul>
<li><strong>dataframe</strong>: pandas object that contains all variables</li>
</ul>
<p>Example:</p>
<pre><code>from brent import DAG
from brent.common import make_fake_df
# let's start with a new dataset
df = make_fake_df(4)
dag = DAG(df).add_edge(&quot;a&quot;, &quot;b&quot;).add_edge(&quot;b&quot;, &quot;c&quot;).add_edge(&quot;c&quot;,&quot;d&quot;)
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, dataframe: pd.DataFrame):
    &#34;&#34;&#34;
    Create a new `brent.DAG` from a dataframe.

    Inputs:

    - **dataframe**: pandas object that contains all variables

    Example:

    ```
    from brent import DAG
    from brent.common import make_fake_df
    # let&#39;s start with a new dataset
    df = make_fake_df(4)
    dag = DAG(df).add_edge(&#34;a&#34;, &#34;b&#34;).add_edge(&#34;b&#34;, &#34;c&#34;).add_edge(&#34;c&#34;,&#34;d&#34;)
    ```
    &#34;&#34;&#34;
    self.df = dataframe
    self.graph = nx.DiGraph()
    for node in self.df.columns:
        self.graph.add_node(node)</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.active_paths"><code class="name flex">
<span>def <span class="ident">active_paths</span></span>(<span>self, node_a, node_b, z=[])</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of all the paths that can influence probability between
<code>node_a</code> and <code>node_b</code>. You can also supply a collection of nodes <code>z</code> that
are given. These nodes might block (or enable) a path to be active. If there
are no active paths between two nodes then this means that the two nodes
are (conditionally if <code>z</code> is given) independant.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def active_paths(self, node_a, node_b, z=list()):
    &#34;&#34;&#34;
    Returns a list of all the paths that can influence probability between
    `node_a` and `node_b`. You can also supply a collection of nodes `z` that
    are given. These nodes might block (or enable) a path to be active. If there
    are no active paths between two nodes then this means that the two nodes
    are (conditionally if `z` is given) independant.
    &#34;&#34;&#34;
    undirected_paths = self.directed_paths(node_a, node_b)
    active_paths = []
    for path in undirected_paths:
        z_path = [f&#34;given({_})&#34; if _ in z else _ for _ in path]
        logging.debug(f&#34;now checking {&#39; &#39;.join(z_path)}&#34;)
        if not is_path_blocked(z_path):
            active_paths.append(z_path)
    return active_paths</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.add_edge"><code class="name flex">
<span>def <span class="ident">add_edge</span></span>(<span>self, source, sink)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds an edge to the graph.</p>
<h2 id="input">Input</h2>
<ul>
<li><strong>source</strong>: Name of a node in the graph</li>
<li><strong>sink</strong>: Name of a node in the graph</li>
</ul>
<h2 id="example">Example</h2>
<pre><code>from brent import DAG
from brent.common import make_fake_df

(DAG(dataframe=make_fake_df(4))
    .add_edge(&quot;a&quot;, &quot;b&quot;)
    .add_edge(&quot;b&quot;, &quot;c&quot;)
    .add_edge(&quot;c&quot;, &quot;d&quot;))
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_edge(self, source, sink) -&gt; &#39;DAG&#39;:
    &#34;&#34;&#34;
    Adds an edge to the graph.

    ## Input

    - **source**: Name of a node in the graph
    - **sink**: Name of a node in the graph

    ## Example

    ```
    from brent import DAG
    from brent.common import make_fake_df

    (DAG(dataframe=make_fake_df(4))
        .add_edge(&#34;a&#34;, &#34;b&#34;)
        .add_edge(&#34;b&#34;, &#34;c&#34;)
        .add_edge(&#34;c&#34;, &#34;d&#34;))
    ```
    &#34;&#34;&#34;
    if source not in self.df.columns:
        raise ValueError(f&#34;cause {source} not in dataframe&#34;)
    if sink not in self.df.columns:
        raise ValueError(f&#34;effect {sink} not in dataframe&#34;)
    new_graph = self.graph.copy()
    new_graph.add_edge(source, sink)
    if not nx.is_directed_acyclic_graph(new_graph):
        raise ValueError(f&#34;edge {source} -&gt; {sink} causes DAG to get cycle&#34;)
    self.graph.add_edge(source, sink)
    logging.debug(f&#34;created connection {source} -&gt; {sink}&#34;)
    return self</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.calc_node_table"><code class="name flex">
<span>def <span class="ident">calc_node_table</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates probability table for a given node.</p>
<p>Suppose we have graph <code>A -&gt; B -&gt; C</code>: <code>.calc_node_table("b")</code>
call will calculate <code>P(B|A)</code> in the <code>probs</code> column of the result.</p>
<h2 id="input">Input</h2>
<ul>
<li><strong>name</strong>: Name of a node/variable in the graph</li>
</ul></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def calc_node_table(self, name):
    &#34;&#34;&#34;
    Calculates probability table for a given node.

    Suppose we have graph `A -&gt; B -&gt; C`: `.calc_node_table(&#34;b&#34;)`
    call will calculate `P(B|A)` in the `probs` column of the result.

    ## Input

    - **name**: Name of a node/variable in the graph
    &#34;&#34;&#34;
    parents = self.parents(name)
    tbl = self.df.copy()
    logging.debug(f&#34;creating node table node={name} parents={parents}&#34;)

    def calculate_parents_size(dataf, groups=[]):
        return (dataf
                .assign(count=1)
                .groupby(groups)
                .transform(np.sum)[&#39;count&#39;])

    if len(parents) == 0:
        tbl = tbl.assign(parent_size=lambda d: d.shape[0])
    else:
        tbl = tbl.assign(parent_size=lambda d: calculate_parents_size(d, list(parents)))
    return (tbl
            .assign(node_size=lambda d: calculate_parents_size(d, list(parents) + [name]))
            .assign(prob=lambda d: d[&#39;node_size&#39;] / d[&#39;parent_size&#39;])
            [list(parents) + [name] + [&#34;prob&#34;]]
            .drop_duplicates()
            .reset_index(drop=True))</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.children"><code class="name flex">
<span>def <span class="ident">children</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the children of a node.</p>
<h2 id="input">Input</h2>
<ul>
<li><strong>node</strong>: Name of a node</li>
</ul>
<h2 id="example">Example</h2>
<pre><code>from brent import DAG
from brent.common import make_fake_df

dag = (DAG(dataframe=make_fake_df(4))
    .add_edge(&quot;a&quot;, &quot;b&quot;)
    .add_edge(&quot;b&quot;, &quot;c&quot;)
    .add_edge(&quot;c&quot;, &quot;d&quot;))

dag.children(&quot;b&quot;) #outputs &quot;c&quot;
dag.children(&quot;c&quot;) #outputs &quot;d&quot;
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def children(self, node):
    &#34;&#34;&#34;
    Return the children of a node.

    ## Input

    - **node**: Name of a node

    ## Example

    ```
    from brent import DAG
    from brent.common import make_fake_df

    dag = (DAG(dataframe=make_fake_df(4))
        .add_edge(&#34;a&#34;, &#34;b&#34;)
        .add_edge(&#34;b&#34;, &#34;c&#34;)
        .add_edge(&#34;c&#34;, &#34;d&#34;))

    dag.children(&#34;b&#34;) #outputs &#34;c&#34;
    dag.children(&#34;c&#34;) #outputs &#34;d&#34;
    ```
    &#34;&#34;&#34;
    return set(self.graph.successors(node))</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.connections"><code class="name flex">
<span>def <span class="ident">connections</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Return all nodes connected to the one passed in.</p>
<h2 id="input">Input</h2>
<ul>
<li><strong>node</strong>: Name of a node</li>
</ul>
<h2 id="example">Example</h2>
<pre><code>from brent import DAG
from brent.common import make_fake_df

dag = (DAG(dataframe=make_fake_df(4))
    .add_edge(&quot;a&quot;, &quot;b&quot;)
    .add_edge(&quot;b&quot;, &quot;c&quot;)
    .add_edge(&quot;c&quot;, &quot;d&quot;))

dag.children(&quot;b&quot;) #outputs [&quot;a&quot;,&quot;c&quot;]
dag.children(&quot;c&quot;) #outputs [&quot;b&quot;,&quot;d&quot;]
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def connections(self, node):
    &#34;&#34;&#34;
    Return all nodes connected to the one passed in.

    ## Input

    - **node**: Name of a node

    ## Example

    ```
    from brent import DAG
    from brent.common import make_fake_df

    dag = (DAG(dataframe=make_fake_df(4))
        .add_edge(&#34;a&#34;, &#34;b&#34;)
        .add_edge(&#34;b&#34;, &#34;c&#34;)
        .add_edge(&#34;c&#34;, &#34;d&#34;))

    dag.children(&#34;b&#34;) #outputs [&#34;a&#34;,&#34;c&#34;]
    dag.children(&#34;c&#34;) #outputs [&#34;b&#34;,&#34;d&#34;]
    ```
    &#34;&#34;&#34;
    return set(list(self.children(node)) + list(self.parents(node)))</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a copy of the current DAG.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Returns a copy of the current DAG.&#34;&#34;&#34;
    new_dag = DAG(self.df)
    new_dag.graph = self.graph
    return new_dag</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.directed_paths"><code class="name flex">
<span>def <span class="ident">directed_paths</span></span>(<span>self, node_a, node_b)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def directed_paths(self, node_a, node_b):
    output_paths = []
    for path in self.undirected_paths(node_a, node_b):
        windowed = list(window(path))
        new_path = []
        for n1, n2 in windowed:
            new_path.append(n1)
            new_path.append(self.edge_direction(n1, n2))
        new_path.append(n2)
        output_paths.append(new_path)
        logging.debug(f&#34;found directed path: {&#39; &#39;.join(new_path)}&#34;)
    return output_paths</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.edge_direction"><code class="name flex">
<span>def <span class="ident">edge_direction</span></span>(<span>self, node_a, node_b)</span>
</code></dt>
<dd>
<section class="desc"><p>Determines the <code>&lt;-</code> vs. <code>-&gt;</code> direction of an edge between two nodes.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def edge_direction(self, node_a, node_b):
    &#34;&#34;&#34;Determines the `&lt;-` vs. `-&gt;` direction of an edge between two nodes.&#34;&#34;&#34;
    if node_b in self.parents(node_a):
        return &#34;&lt;-&#34;
    if node_a in self.parents(node_b):
        return &#34;-&gt;&#34;
    raise ValueError(f&#34;node &#39;{node_a}&#39; is not connected to &#39;{node_b}&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.independences"><code class="name flex">
<span>def <span class="ident">independences</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p><strong>NOT IMPLEMENTED YET</strong></p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def independences(self):
    &#34;&#34;&#34;
    **NOT IMPLEMENTED YET**
    &#34;&#34;&#34;
    # https://www.slideshare.net/duytungpham18/lecture-1-graphical-models
    pass</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.merge_probs"><code class="name flex">
<span>def <span class="ident">merge_probs</span></span>(<span>self, this_df, that_df)</span>
</code></dt>
<dd>
<section class="desc"><p>Merges two probability dataframes while checking if nodes
are connected in the graph. If <code>this_df</code> denotes <code>p(C|A,B)</code>
in table form and <code>that_df</code> denotes <code>p(B|A)</code> in table form
then the output of this function will denote <code>p(C,B|A)</code> in
table form. Note that this method is mainly meant for internal usage.</p>
<h2 id="input">Input</h2>
<ul>
<li><strong>this_df</strong>: Name of a node/variable in the graph, say <code>p(C|A,B)</code></li>
<li><strong>that_df</strong>: Name of a node/variable in the graph, say <code>p(B|A)</code></li>
</ul>
<h2 id="output">Output</h2>
<p>A dataframe that merges the two former tables, say <code>p(C,B|A)</code>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def merge_probs(self, this_df, that_df):
    &#34;&#34;&#34;
    Merges two probability dataframes while checking if nodes
    are connected in the graph. If `this_df` denotes `p(C|A,B)`
    in table form and `that_df` denotes `p(B|A)` in table form
    then the output of this function will denote `p(C,B|A)` in
    table form. Note that this method is mainly meant for internal usage.

    ## Input

    - **this_df**: Name of a node/variable in the graph, say `p(C|A,B)`
    - **that_df**: Name of a node/variable in the graph, say `p(B|A)`

    ## Output

    A dataframe that merges the two former tables, say `p(C,B|A)`.
    &#34;&#34;&#34;
    common_cols = list(set(this_df.columns)
                       .intersection(set(that_df.columns))
                       .difference({&#34;prob&#34;}))
    if len(common_cols) == 0:
        columns = set(that_df.columns).difference({&#34;prob&#34;})
        loose_tables = []
        for c in columns:
            for value in self.calc_node_table(c)[c].values:
                loose_tables.append(this_df.assign(**{c: value}))
        join_able = pd.concat(loose_tables)
        return self.merge_probs(join_able, that_df)
    return (this_df
            .set_index(common_cols)
            .join(that_df.set_index(common_cols), lsuffix=&#34;1&#34;, rsuffix=&#34;2&#34;)
            .assign(prob=lambda x: normalise(x.prob1 * x.prob2))
            .drop(&#34;prob1&#34;, axis=1)
            .drop(&#34;prob2&#34;, axis=1)
            .reset_index())</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.nx_plot"><code class="name flex">
<span>def <span class="ident">nx_plot</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>A customizable plotting function. The function comes from <code>networkx</code>.
It merely wraps around the <code>nx.draw</code> method, documentation of this project
can be found <a href="https://networkx.github.io/documentation/stable/index.html">here</a>.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def nx_plot(self, **kwargs):
    &#34;&#34;&#34;
    A customizable plotting function. The function comes from `networkx`.
    It merely wraps around the `nx.draw` method, documentation of this project
    can be found [here](https://networkx.github.io/documentation/stable/index.html).
    &#34;&#34;&#34;
    nx.draw(self.graph, node_size=500, with_labels=True, node_color=&#34;white&#34;, **kwargs)</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.parents"><code class="name flex">
<span>def <span class="ident">parents</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the parents of a node.</p>
<h2 id="input">Input</h2>
<ul>
<li><strong>node</strong>: Name of a node</li>
</ul>
<h2 id="example">Example</h2>
<pre><code>from brent import DAG
from brent.common import make_fake_df

dag = (DAG(dataframe=make_fake_df(4))
    .add_edge(&quot;a&quot;, &quot;b&quot;)
    .add_edge(&quot;b&quot;, &quot;c&quot;)
    .add_edge(&quot;c&quot;, &quot;d&quot;))

dag.children(&quot;b&quot;) #outputs &quot;a&quot;
dag.children(&quot;c&quot;) #outputs &quot;b&quot;
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def parents(self, node):
    &#34;&#34;&#34;
    Return the parents of a node.

    ## Input

    - **node**: Name of a node

    ## Example

    ```
    from brent import DAG
    from brent.common import make_fake_df

    dag = (DAG(dataframe=make_fake_df(4))
        .add_edge(&#34;a&#34;, &#34;b&#34;)
        .add_edge(&#34;b&#34;, &#34;c&#34;)
        .add_edge(&#34;c&#34;, &#34;d&#34;))

    dag.children(&#34;b&#34;) #outputs &#34;a&#34;
    dag.children(&#34;c&#34;) #outputs &#34;b&#34;
    ```
    &#34;&#34;&#34;
    return set(self.graph.predecessors(node))</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>A pretty plotting function.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def plot(self):
    &#34;&#34;&#34;A pretty plotting function.&#34;&#34;&#34;
    d = Digraph()
    d.attr(rankdir=&#39;LR&#39;)
    d.attr(&#39;node&#39;, shape=&#39;circle&#39;)
    for n in self.graph.nodes:
        d.node(n)
    for n1, n2 in self.graph.edges:
        d.edge(n1, n2)
    return d</code></pre>
</details>
</dd>
<dt id="brent.graph.DAG.undirected_paths"><code class="name flex">
<span>def <span class="ident">undirected_paths</span></span>(<span>self, node_a, node_b)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns a list of all the paths that are between <code>node_a</code> and <code>node_b</code>.
These paths do not take the direction into account and will turn the
directed graph into an undirected one.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def undirected_paths(self, node_a, node_b):
    &#34;&#34;&#34;
    Returns a list of all the paths that are between `node_a` and `node_b`.
    These paths do not take the direction into account and will turn the
    directed graph into an undirected one.
    &#34;&#34;&#34;
    return list(nx.all_simple_paths(self.undirected, node_a, node_b))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="brent" href="index.html">brent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="brent.graph.DAG" href="#brent.graph.DAG">DAG</a></code></h4>
<ul class="two-column">
<li><code><a title="brent.graph.DAG.__init__" href="#brent.graph.DAG.__init__">__init__</a></code></li>
<li><code><a title="brent.graph.DAG.active_paths" href="#brent.graph.DAG.active_paths">active_paths</a></code></li>
<li><code><a title="brent.graph.DAG.add_edge" href="#brent.graph.DAG.add_edge">add_edge</a></code></li>
<li><code><a title="brent.graph.DAG.calc_node_table" href="#brent.graph.DAG.calc_node_table">calc_node_table</a></code></li>
<li><code><a title="brent.graph.DAG.children" href="#brent.graph.DAG.children">children</a></code></li>
<li><code><a title="brent.graph.DAG.connections" href="#brent.graph.DAG.connections">connections</a></code></li>
<li><code><a title="brent.graph.DAG.copy" href="#brent.graph.DAG.copy">copy</a></code></li>
<li><code><a title="brent.graph.DAG.directed_paths" href="#brent.graph.DAG.directed_paths">directed_paths</a></code></li>
<li><code><a title="brent.graph.DAG.edge_direction" href="#brent.graph.DAG.edge_direction">edge_direction</a></code></li>
<li><code><a title="brent.graph.DAG.edges" href="#brent.graph.DAG.edges">edges</a></code></li>
<li><code><a title="brent.graph.DAG.independences" href="#brent.graph.DAG.independences">independences</a></code></li>
<li><code><a title="brent.graph.DAG.marginal_table" href="#brent.graph.DAG.marginal_table">marginal_table</a></code></li>
<li><code><a title="brent.graph.DAG.merge_probs" href="#brent.graph.DAG.merge_probs">merge_probs</a></code></li>
<li><code><a title="brent.graph.DAG.nodes" href="#brent.graph.DAG.nodes">nodes</a></code></li>
<li><code><a title="brent.graph.DAG.nx_plot" href="#brent.graph.DAG.nx_plot">nx_plot</a></code></li>
<li><code><a title="brent.graph.DAG.origin_nodes" href="#brent.graph.DAG.origin_nodes">origin_nodes</a></code></li>
<li><code><a title="brent.graph.DAG.parents" href="#brent.graph.DAG.parents">parents</a></code></li>
<li><code><a title="brent.graph.DAG.plot" href="#brent.graph.DAG.plot">plot</a></code></li>
<li><code><a title="brent.graph.DAG.undirected" href="#brent.graph.DAG.undirected">undirected</a></code></li>
<li><code><a title="brent.graph.DAG.undirected_paths" href="#brent.graph.DAG.undirected_paths">undirected_paths</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>